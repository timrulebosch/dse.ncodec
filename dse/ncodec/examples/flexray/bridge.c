// Copyright 2025 Robert Bosch GmbH
//
// SPDX-License-Identifier: Apache-2.0

/*
FlexRay Bridged Network Example
===============================

FlexRay Network (Real or Simulated)
└── ECU / VECU
└── ECU / VECU
└── Bridge (NCodec)
        └── NCodec ── VECU (SoftECU)
        └── NCodec ── VECU (Runnable)

*/

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <dse/ncodec/codec.h>
#include <dse/ncodec/interface/pdu.h>
#include <dse/ncodec/stream/stream.h>

#define UNUSED(x)  ((void)x)
#define BUFFER_LEN 1024


/* Stub FlexRay Controller Interface. */
static uint16_t FlexrayMT = 1000;
static uint8_t  FlexrayCycle = 24;
static uint8_t  FlexrayState = NCodecPduFlexrayTransceiverStateFrameSync;
typedef struct FlexrayLpdu {
    /* Configuration items. */
    uint8_t        channel;
    uint16_t       slot_id;
    uint8_t        base_cycle;
    uint8_t        cycle_repetition;
    /* Instance items. */
    uint8_t        cycle;
    const uint8_t* payload;
    uint8_t        payload_len;
    bool           null_frame;
    bool           startup_frame;
} FlexrayLpdu;
static void flexray_tx(FlexrayLpdu* lpdu)
{
    UNUSED(lpdu);
}
static FlexrayLpdu* flexray_rx(void)
{
    static FlexrayLpdu __lpdu = { .slot_id = 42,
        .cycle = 23,
        .payload = NULL,
        .payload_len = 0,
        .null_frame = true };
    return (rand() % 2) ? &__lpdu : NULL;  // NOLINT
}


/* FlexRay Bridge with NCodec. */
#define MIMETYPE                                                               \
    "application/x-automotive-bus; "                                           \
    "interface=stream;type=pdu;schema=fbs;"                                    \
    "ecu_id=1;cc_id=0;swc_id=1"

static NCODEC* nc = NULL;

NCodecPduFlexrayLpduConfig lookup(uint32_t id)
{
    UNUSED(id);
    NCodecPduFlexrayLpduConfig config = { 0 };
    return config;
}

void bridge_create(void)
{
    NCodecStreamVTable* stream = ncodec_buffer_stream_create(BUFFER_LEN);
    nc = ncodec_open(MIMETYPE, stream);
    if (nc == NULL) {
        printf("Open failed (errno %d)\n", errno);
        exit(errno);
    }

    /* Configure NCodec for bridge mode (can also be done with the MIMEtype). */
    ncodec_config(
        nc, (struct NCodecConfigItem){ .name = "mode", .value = "bridge" });
}

int bridge_step(void)
{
    /*
    Bridge: TX -> FlexRay Network
    -----------------------------
    In FlexRay "Bridge" mode calling ncodec_read() will return all new PDU's
    generated by _all_ bridged nodes. Those PDU's are then introduced into the
    bridged network via its FlexRay Controller (to be transmitted). */
    for (;;) {
        NCodecPdu pdu = {};
        int       rc = ncodec_read(nc, &pdu);
        if (rc < 0) break;
        if (pdu.transport_type != NCodecPduTransportTypeFlexray ||
            pdu.transport.flexray.metadata_type !=
                NCodecPduFlexrayMetadataTypeLpdu) {
            continue;
        }
        if (pdu.transport.flexray.metadata.lpdu.status !=
            NCodecPduFlexrayLpduStatusNotTransmitted) {
            continue;
        }
        NCodecPduFlexrayLpduConfig lpdu_config = lookup(pdu.id);
        flexray_tx(&(struct FlexrayLpdu){
            .slot_id = pdu.id,
            .payload = pdu.payload,  // Called API does immediate memcpy()!
            .payload_len = pdu.payload_len,
            .channel = lpdu_config.channel,
            .base_cycle = lpdu_config.base_cycle,
            .cycle_repetition = lpdu_config.cycle_repetition,
        });
    }
    ncodec_truncate(nc);

    /*
    Bridge: Rx <- FlexRay Network
    -----------------------------
    All Rx Frames from the Flexray Network (since the last call) are forwarded
    to the bridged nodes via the NCodec.
    */
    for (FlexrayLpdu* lpdu = NULL; (lpdu = flexray_rx()) != NULL;) {
        /* clang-format off */
        ncodec_write(nc, &(struct NCodecPdu){
            .id = lpdu->slot_id,
            .payload = lpdu->payload,
            .payload_len = lpdu->payload_len,
            .transport_type = NCodecPduTransportTypeFlexray,
            .transport.flexray = {
                .metadata_type = NCodecPduFlexrayMetadataTypeLpdu,
                .metadata.lpdu = {
                    .cycle = lpdu->cycle,
                    .null_frame = lpdu->null_frame,
                    .startup_frame = lpdu->startup_frame,
                    .status = NCodecPduFlexrayLpduStatusTransmitted,
                },
            },
        });
        /* clang-format on */
    }

    /*
    Bridge: FlexRay Network State
    -----------------------------
    Inform the bridged nodes of the FlexRay Network condition.
    */
    /* clang-format off */
    ncodec_write(nc, &(struct NCodecPdu){
        .transport_type = NCodecPduTransportTypeFlexray,
        .transport.flexray = {
            .metadata_type = NCodecPduFlexrayMetadataTypeStatus,
            .metadata.status = {
                .macrotick = FlexrayMT,
                .cycle = FlexrayCycle,
                .channel[0].tcvr_state = FlexrayState,
            },
        },
    });
    /* clang-format on */
    ncodec_flush(nc);
    return 0;
}

void bridge_destroy(void)
{
    ncodec_close(nc);
}

int main(int argc, char* argv[])
{
    UNUSED(argc);
    UNUSED(argv);

    bridge_create();
    bridge_step();
    bridge_destroy();

    return 0;
}
